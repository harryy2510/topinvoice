# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Company {
  city: String
  country: CountryCode!
  createdAt: DateTime!
  id: ID!
  invoices(
    """Specify to filter the records returned."""
    filter: InvoiceFilter = {}

    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to sort results."""
    sorting: [InvoiceSort!] = []
  ): CompanyInvoicesConnection
  invoicesAggregate(
    """Filter to find records to aggregate on"""
    filter: InvoiceAggregateFilter
  ): [CompanyInvoicesAggregateResponse!]!
  name: String!
  postalCode: PostalCode!
  state: String
  streetAddress: String
  taxName: String
  taxRate: Int!
  updatedAt: DateTime!
  user: User!
  website: String
}

input CompanyAggregateFilter {
  and: [CompanyAggregateFilter!]
  city: StringFieldComparison
  country: CountryCodeAdaptedScalarFilterComparison
  id: IDFilterComparison
  name: StringFieldComparison
  or: [CompanyAggregateFilter!]
  postalCode: PostalCodeAdaptedScalarFilterComparison
  state: StringFieldComparison
}

type CompanyAggregateGroupBy {
  city: String
  country: CountryCode
  id: ID
  name: String
  postalCode: PostalCode
  state: String
}

type CompanyAggregateResponse {
  count: CompanyCountAggregate
  groupBy: CompanyAggregateGroupBy
  max: CompanyMaxAggregate
  min: CompanyMinAggregate
}

type CompanyConnection {
  """Array of nodes."""
  nodes: [Company!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type CompanyCountAggregate {
  city: Int
  country: Int
  id: Int
  name: Int
  postalCode: Int
  state: Int
}

input CompanyDeleteFilter {
  and: [CompanyDeleteFilter!]
  city: StringFieldComparison
  country: CountryCodeAdaptedScalarFilterComparison
  id: IDFilterComparison
  name: StringFieldComparison
  or: [CompanyDeleteFilter!]
  postalCode: PostalCodeAdaptedScalarFilterComparison
  state: StringFieldComparison
}

type CompanyDeleteResponse {
  city: String
  country: CountryCode
  createdAt: DateTime
  id: ID
  invoices: [Invoice!]
  name: String
  postalCode: PostalCode
  state: String
  streetAddress: String
  taxName: String
  taxRate: Int
  updatedAt: DateTime
  user: User
  website: String
}

input CompanyFilter {
  and: [CompanyFilter!]
  city: StringFieldComparison
  country: CountryCodeAdaptedScalarFilterComparison
  id: IDFilterComparison
  name: StringFieldComparison
  or: [CompanyFilter!]
  postalCode: PostalCodeAdaptedScalarFilterComparison
  state: StringFieldComparison
}

type CompanyInvoicesAggregateGroupBy {
  id: ID
  invoiceNumber: String
  status: InvoiceStatusEnum
}

type CompanyInvoicesAggregateResponse {
  count: CompanyInvoicesCountAggregate
  groupBy: CompanyInvoicesAggregateGroupBy
  max: CompanyInvoicesMaxAggregate
  min: CompanyInvoicesMinAggregate
}

type CompanyInvoicesConnection {
  """Array of nodes."""
  nodes: [Invoice!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type CompanyInvoicesCountAggregate {
  id: Int
  invoiceNumber: Int
  status: Int
}

type CompanyInvoicesMaxAggregate {
  id: ID
  invoiceNumber: String
  status: InvoiceStatusEnum
}

type CompanyInvoicesMinAggregate {
  id: ID
  invoiceNumber: String
  status: InvoiceStatusEnum
}

type CompanyMaxAggregate {
  city: String
  country: CountryCode
  id: ID
  name: String
  postalCode: PostalCode
  state: String
}

type CompanyMinAggregate {
  city: String
  country: CountryCode
  id: ID
  name: String
  postalCode: PostalCode
  state: String
}

input CompanySort {
  direction: SortDirection!
  field: CompanySortFields!
  nulls: SortNulls
}

enum CompanySortFields {
  city
  country
  id
  name
  postalCode
  state
}

"""Cursor for paging through collections"""
scalar ConnectionCursor

"""A country code as defined by ISO 3166-1 alpha-2"""
scalar CountryCode

input CountryCodeAdaptedScalarFilterComparison {
  eq: CountryCode
  gt: CountryCode
  gte: CountryCode
  iLike: CountryCode
  in: [CountryCode!]
  is: Boolean
  isNot: Boolean
  like: CountryCode
  lt: CountryCode
  lte: CountryCode
  neq: CountryCode
  notILike: CountryCode
  notIn: [CountryCode!]
  notLike: CountryCode
}

input CreateCompany {
  city: String
  country: CountryCode!
  currency: String
  name: String!
  postalCode: PostalCode!
  state: String
  streetAddress: String
  taxName: String
  taxRate: Int!
  website: String
}

input CreateInvoice {
  companyId: String!
  dueDate: DateTime
  invoiceDate: DateTime
  invoiceNumber: String!
  paidDate: DateTime
  status: InvoiceStatusEnum
}

input CreateInvoiceItem {
  description: String
  discount: Int
  invoiceId: String!
  name: String!
  price: Int!
  quantity: Int!
  unit: String
}

input CreateManyInvoiceItemsInput {
  """Array of records to create"""
  invoiceItems: [CreateInvoiceItem!]!
}

input CreateOneCompanyInput {
  """The record to create"""
  company: CreateCompany!
}

input CreateOneInvoiceInput {
  """The record to create"""
  invoice: CreateInvoice!
}

input CreateOneInvoiceItemInput {
  """The record to create"""
  invoiceItem: CreateInvoiceItem!
}

input CreateUser {
  email: EmailAddress!
  firstName: String!
  lastName: String
  password: Password!
  phone: PhoneNumber
  profileImage: String
}

type DataCode {
  createdAt: DateTime!
  data: JSON
  expireAt: DateTime
  expired: Boolean!
  id: ID!
  parent: String!
  type: DataCodeEnum!
  updatedAt: DateTime!
  used: Boolean!
}

type DataCodeAggregateGroupBy {
  id: ID
  parent: String
}

type DataCodeCountAggregate {
  id: Int
  parent: Int
}

type DataCodeEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the DataCode"""
  node: DataCode!
}

enum DataCodeEnum {
  ForgotPassword
  Welcome
}

type DataCodeMaxAggregate {
  id: ID
  parent: String
}

type DataCodeMinAggregate {
  id: ID
  parent: String
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DeleteManyCompaniesInput {
  """Filter to find records to delete"""
  filter: CompanyDeleteFilter!
}

input DeleteManyInvoiceItemsInput {
  """Filter to find records to delete"""
  filter: InvoiceItemDeleteFilter!
}

input DeleteManyInvoicesInput {
  """Filter to find records to delete"""
  filter: InvoiceDeleteFilter!
}

type DeleteManyResponse {
  """The number of records deleted."""
  deletedCount: Int!
}

input DeleteOneCompanyInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneInvoiceInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneInvoiceItemInput {
  """The id of the record to delete."""
  id: ID!
}

"""
A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
"""
scalar EmailAddress

input ForgotPasswordInput {
  email: EmailAddress!
}

input IDFilterComparison {
  eq: ID
  gt: ID
  gte: ID
  iLike: ID
  in: [ID!]
  is: Boolean
  isNot: Boolean
  like: ID
  lt: ID
  lte: ID
  neq: ID
  notILike: ID
  notIn: [ID!]
  notLike: ID
}

type Invoice {
  company: Company!
  createdAt: DateTime!
  dueDate: DateTime
  id: ID!
  invoiceDate: DateTime!
  invoiceNumber: String!
  items(
    """Specify to filter the records returned."""
    filter: InvoiceItemFilter = {}

    """Specify to sort results."""
    sorting: [InvoiceItemSort!] = []
  ): [InvoiceItem!]
  paidDate: DateTime
  status: InvoiceStatusEnum!
  updatedAt: DateTime!
  user: User!
}

input InvoiceAggregateFilter {
  and: [InvoiceAggregateFilter!]
  id: IDFilterComparison
  invoiceNumber: StringFieldComparison
  or: [InvoiceAggregateFilter!]
  status: InvoiceStatusEnumFilterComparison
}

type InvoiceAggregateGroupBy {
  id: ID
  invoiceNumber: String
  status: InvoiceStatusEnum
}

type InvoiceConnection {
  """Array of nodes."""
  nodes: [Invoice!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type InvoiceCountAggregate {
  id: Int
  invoiceNumber: Int
  status: Int
}

input InvoiceDeleteFilter {
  and: [InvoiceDeleteFilter!]
  id: IDFilterComparison
  invoiceNumber: StringFieldComparison
  or: [InvoiceDeleteFilter!]
  status: InvoiceStatusEnumFilterComparison
}

type InvoiceDeleteResponse {
  company: Company
  createdAt: DateTime
  dueDate: DateTime
  id: ID
  invoiceDate: DateTime
  invoiceNumber: String
  items: [InvoiceItem!]
  paidDate: DateTime
  status: InvoiceStatusEnum
  updatedAt: DateTime
  user: User
}

input InvoiceFilter {
  and: [InvoiceFilter!]
  id: IDFilterComparison
  invoiceNumber: StringFieldComparison
  or: [InvoiceFilter!]
  status: InvoiceStatusEnumFilterComparison
}

type InvoiceItem {
  createdAt: DateTime!
  description: String
  discount: Int
  id: ID!
  invoice: Invoice!
  name: String!
  price: Int!
  quantity: Int!
  unit: String
  updatedAt: DateTime!
  user: User!
}

type InvoiceItemAggregateGroupBy {
  id: ID
  name: String
}

type InvoiceItemCountAggregate {
  id: Int
  name: Int
}

input InvoiceItemDeleteFilter {
  and: [InvoiceItemDeleteFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  or: [InvoiceItemDeleteFilter!]
}

type InvoiceItemDeleteResponse {
  createdAt: DateTime
  description: String
  discount: Int
  id: ID
  invoice: Invoice
  name: String
  price: Int
  quantity: Int
  unit: String
  updatedAt: DateTime
  user: User
}

input InvoiceItemFilter {
  and: [InvoiceItemFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  or: [InvoiceItemFilter!]
}

type InvoiceItemMaxAggregate {
  id: ID
  name: String
}

type InvoiceItemMinAggregate {
  id: ID
  name: String
}

input InvoiceItemSort {
  direction: SortDirection!
  field: InvoiceItemSortFields!
  nulls: SortNulls
}

enum InvoiceItemSortFields {
  id
  name
}

input InvoiceItemUpdateFilter {
  and: [InvoiceItemUpdateFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  or: [InvoiceItemUpdateFilter!]
}

type InvoiceMaxAggregate {
  id: ID
  invoiceNumber: String
  status: InvoiceStatusEnum
}

type InvoiceMinAggregate {
  id: ID
  invoiceNumber: String
  status: InvoiceStatusEnum
}

input InvoiceSort {
  direction: SortDirection!
  field: InvoiceSortFields!
  nulls: SortNulls
}

enum InvoiceSortFields {
  id
  invoiceNumber
  status
}

enum InvoiceStatusEnum {
  Draft
  Paid
  Sent
}

input InvoiceStatusEnumFilterComparison {
  eq: InvoiceStatusEnum
  gt: InvoiceStatusEnum
  gte: InvoiceStatusEnum
  iLike: InvoiceStatusEnum
  in: [InvoiceStatusEnum!]
  is: Boolean
  isNot: Boolean
  like: InvoiceStatusEnum
  lt: InvoiceStatusEnum
  lte: InvoiceStatusEnum
  neq: InvoiceStatusEnum
  notILike: InvoiceStatusEnum
  notIn: [InvoiceStatusEnum!]
  notLike: InvoiceStatusEnum
}

input InvoiceUpdateFilter {
  and: [InvoiceUpdateFilter!]
  id: IDFilterComparison
  invoiceNumber: StringFieldComparison
  or: [InvoiceUpdateFilter!]
  status: InvoiceStatusEnumFilterComparison
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

input LoginInput {
  email: EmailAddress!
  password: Password!
}

type LoginResponse {
  accessToken: String!
  expiry: String!
  user: User!
}

type Mutation {
  createManyInvoiceItems(input: CreateManyInvoiceItemsInput!): [InvoiceItem!]!
  createOneCompany(input: CreateOneCompanyInput!): Company!
  createOneInvoice(input: CreateOneInvoiceInput!): Invoice!
  createOneInvoiceItem(input: CreateOneInvoiceItemInput!): InvoiceItem!
  deleteManyCompanies(input: DeleteManyCompaniesInput!): DeleteManyResponse!
  deleteManyInvoiceItems(input: DeleteManyInvoiceItemsInput!): DeleteManyResponse!
  deleteManyInvoices(input: DeleteManyInvoicesInput!): DeleteManyResponse!
  deleteOneCompany(input: DeleteOneCompanyInput!): CompanyDeleteResponse!
  deleteOneInvoice(input: DeleteOneInvoiceInput!): InvoiceDeleteResponse!
  deleteOneInvoiceItem(input: DeleteOneInvoiceItemInput!): InvoiceItemDeleteResponse!
  forgotPassword(input: ForgotPasswordInput!): Boolean!
  login(input: LoginInput!): LoginResponse!
  register(input: CreateUser!): LoginResponse!
  resetPassword(input: ResetPasswordInput!): Boolean!
  setCompanyOnInvoice(input: SetCompanyOnInvoiceInput!): Invoice!
  setUserOnInvoice(input: SetUserOnInvoiceInput!): Invoice!
  updateManyInvoiceItems(input: UpdateManyInvoiceItemsInput!): UpdateManyResponse!
  updateManyInvoices(input: UpdateManyInvoicesInput!): UpdateManyResponse!
  updateOneCompany(input: UpdateOneCompanyInput!): Company!
  updateOneInvoice(input: UpdateOneInvoiceInput!): Invoice!
  updateOneInvoiceItem(input: UpdateOneInvoiceItemInput!): InvoiceItem!
  updateOneUser(input: UpdateOneUserInput!): User!
}

type OffsetPageInfo {
  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean
}

input OffsetPaging {
  """Limit the number of records returned"""
  limit: Int

  """Offset to start returning records from"""
  offset: Int
}

type PageInfo {
  """The cursor of the last returned record."""
  endCursor: ConnectionCursor

  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean

  """The cursor of the first returned record."""
  startCursor: ConnectionCursor
}

"""A field whose value conforms to strong password"""
scalar Password

"""
A field whose value conforms to the standard E.164 format as specified in: https://en.wikipedia.org/wiki/E.164. Basically this is +17895551234.
"""
scalar PhoneNumber

"""
A field whose value conforms to the standard postal code formats for United States, United Kingdom, Germany, Canada, France, Italy, Australia, Netherlands, Spain, Denmark, Sweden, Belgium, India, Austria, Portugal, Switzerland or Luxembourg.
"""
scalar PostalCode

input PostalCodeAdaptedScalarFilterComparison {
  eq: PostalCode
  gt: PostalCode
  gte: PostalCode
  iLike: PostalCode
  in: [PostalCode!]
  is: Boolean
  isNot: Boolean
  like: PostalCode
  lt: PostalCode
  lte: PostalCode
  neq: PostalCode
  notILike: PostalCode
  notIn: [PostalCode!]
  notLike: PostalCode
}

type Query {
  companies(
    """Specify to filter the records returned."""
    filter: CompanyFilter = {}

    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to sort results."""
    sorting: [CompanySort!] = []
  ): CompanyConnection!
  company(
    """The id of the record to find."""
    id: ID!
  ): Company
  companyAggregate(
    """Filter to find records to aggregate on"""
    filter: CompanyAggregateFilter
  ): [CompanyAggregateResponse!]!
  dataCode(
    """The id of the record to find."""
    id: ID!
  ): DataCode
  invoice(
    """The id of the record to find."""
    id: ID!
  ): Invoice
  invoices(
    """Specify to filter the records returned."""
    filter: InvoiceFilter = {}

    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to sort results."""
    sorting: [InvoiceSort!] = []
  ): InvoiceConnection!
  viewer: User
}

input ResetPasswordInput {
  code: String!
  password: Password!
}

input SetCompanyOnInvoiceInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input SetUserOnInvoiceInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

input StringFieldComparison {
  eq: String
  gt: String
  gte: String
  iLike: String
  in: [String!]
  is: Boolean
  isNot: Boolean
  like: String
  lt: String
  lte: String
  neq: String
  notILike: String
  notIn: [String!]
  notLike: String
}

input UpdateCompany {
  city: String
  country: CountryCode!
  currency: String
  name: String!
  postalCode: PostalCode!
  state: String
  streetAddress: String
  taxName: String
  taxRate: Int!
  website: String
}

input UpdateInvoice {
  dueDate: DateTime
  invoiceDate: DateTime
  invoiceNumber: String!
  paidDate: DateTime
  status: InvoiceStatusEnum
}

input UpdateInvoiceItem {
  description: String
  discount: Int
  name: String!
  price: Int!
  quantity: Int!
  unit: String
}

input UpdateManyInvoiceItemsInput {
  """Filter used to find fields to update"""
  filter: InvoiceItemUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateInvoiceItem!
}

input UpdateManyInvoicesInput {
  """Filter used to find fields to update"""
  filter: InvoiceUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateInvoice!
}

type UpdateManyResponse {
  """The number of records updated."""
  updatedCount: Int!
}

input UpdateOneCompanyInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateCompany!
}

input UpdateOneInvoiceInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateInvoice!
}

input UpdateOneInvoiceItemInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateInvoiceItem!
}

input UpdateOneUserInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateUser!
}

input UpdateUser {
  company: UpdateCompany
  firstName: String
  lastName: String
  phone: PhoneNumber
  profileImage: String
}

type User {
  active: Boolean!
  clients(
    """Specify to filter the records returned."""
    filter: CompanyFilter = {}

    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to sort results."""
    sorting: [CompanySort!] = []
  ): UserClientsConnection
  company: UserCompany
  createdAt: DateTime!
  email: EmailAddress!
  firstName: String!
  id: ID!
  invoiceItems(
    """Specify to filter the records returned."""
    filter: InvoiceItemFilter = {}

    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to sort results."""
    sorting: [InvoiceItemSort!] = []
  ): UserInvoiceItemsConnection
  invoices(
    """Specify to filter the records returned."""
    filter: InvoiceFilter = {}

    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to sort results."""
    sorting: [InvoiceSort!] = []
  ): UserInvoicesConnection
  lastName: String
  phone: PhoneNumber
  profileImage: String
  provider: String
  updatedAt: DateTime!
}

type UserAggregateGroupBy {
  id: ID
}

type UserClientsConnection {
  """Array of nodes."""
  nodes: [Company!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type UserCompany {
  city: String
  country: CountryCode!
  name: String!
  postalCode: PostalCode!
  state: String
  streetAddress: String
  taxName: String
  taxRate: Int!
  website: String
}

type UserCountAggregate {
  id: Int
}

type UserEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the User"""
  node: User!
}

type UserInvoiceItemsConnection {
  """Array of nodes."""
  nodes: [InvoiceItem!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type UserInvoicesConnection {
  """Array of nodes."""
  nodes: [Invoice!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type UserMaxAggregate {
  id: ID
}

type UserMinAggregate {
  id: ID
}